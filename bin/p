#!/usr/local/rvm/bin/ruby

$:.push( File.expand_path( File.dirname( __FILE__ ) ) + '/../lib' )

require 'readline'
require 'yaml'
require 'optparse'
require 'p'


OPTS = { evaluate: true }

OptionParser.new do |opts|
  opts.banner = "Usage: p [options]"

  opts.on( "-e", "--[no-]evaluate", "Evaluate expressions" ) do |v|
    OPTS[:evaluate] = v
  end

  opts.on( "-r", "--reduce", "Parse and reduce expressions" ) do |v|
    OPTS[:reduce] = v
  end

end.parse!


ENVIRONMENT = P::Environment.new

def p_dir
  d = "#{ENV['HOME']}/.p"

  Dir.mkdir( d, 0755 )   unless Dir.exists? d

  d
end

def history_file_path
  p_dir && "#{p_dir}/history.yaml"
end

def load_history
  ary = []

  if (path = history_file_path) && File.exists?( path )
    open( path, 'r' ) do |f|
      ary = YAML.load( f.read )
    end
  end

  Readline::HISTORY.push( *ary )
end

def save_history
  if path = history_file_path
    ary = Readline::HISTORY.to_a

    open( path, 'w' ) do |f|
      f.puts( ary[([0,ary.length-100].min)..(ary.length)].to_yaml )
    end
  end
end

def continue_read( line )
  while next_line = Readline.readline( '', false )
    line << "\n" << next_line  unless next_line.empty?

    begin
      if next_line.empty?
        tree = P.parse( line )
        if OPTS[:reduce]
          puts tree.reduce
        elsif OPTS[:evaluate]
          if o = tree.evaluate( ENVIRONMENT )
            puts o.inspect
          end
        else
          puts tree
        end
        break
      end
    rescue P::NewlineExpectedError => e
      continue_read( line )
    rescue P::UnexpectedEndError => e
      continue_read( line )
    rescue => e
      puts e
      puts e.backtrace.join( "\n" )
      return
    end
  end
end

def read
  while line = Readline.readline( '', false )
    next                   if line.empty?
    break                  if line.strip =~ /^exit$/

    begin
      if line =~ /\n/
        continue_read( line )
      else
        tree = P.parse( line )
        if OPTS[:reduce]
          puts tree.reduce
        elsif OPTS[:evaluate]
          if o = tree.evaluate( ENVIRONMENT )
            puts o.inspect
          end
        else
          puts tree
        end
      end
    rescue P::NewlineExpectedError => e
      continue_read( line )
    rescue P::UnexpectedEndError => e
      continue_read( line )
    rescue => e
      puts e
      puts e.backtrace.join( "\n" )
    ensure
      remove = []
      Readline::HISTORY.each_with_index do |h,i| 
        remove << i  if h == line && i < Readline::HISTORY.length
      end
      remove.reverse.each { |i| Readline::HISTORY.delete_at( i ) }

      Readline::HISTORY.push( line )
    end
  end
end

trap( 'INT' ) { save_history; puts; exit }

load_history
read
save_history
puts

